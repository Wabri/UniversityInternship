angular.module('revux.directives.movements', [])
    .directive('movements', function ($rootScope, $state, MovementsService, $q, Events, UtilsService, DebitCustomerService, TagsAutoTaggingRestService) {
        'use strict';

        /**
         * controller : il controller
         * @param $scope
         */
        var controller = function ($scope, $translate, $filter) {

            $scope.copyPayment = MovementsService.copyPayment;

            // definito api
            if ($scope.api) {
                $scope.api.setOptions = setOptions;
                /*
                 $scope.api.startPointers = startPointers;
                 $scope.api.getNextPointers = getNextPointers;
                 $scope.api.setData = setData;
                 */
                $scope.api.getDefaultData = getDefaultData;
                $scope.api.getData = getData;

                // per determinare se la direttiva è pronta
                $scope.api.isReady = function () {
                    return true;
                }
            }

            // opzioni di base
            $scope.options = {
                pageSize: 10, pagination: true, dwnload: true, filters: {
                    "currencies": [],
                    "customers": [],
                    "products": [],
                    "types": [],
                    "periods": [],
                    "dateFrom": null,
                    "dateTo": null
                }
            };

            // interfaccia al componente delle etichette
            $scope.tagsListApi = {

                beforeRemove: function (item) {

                    // chiama servizio REST e se ok, azzera il componente
                    TagsAutoTaggingRestService.unassociateTagMovement(item.$parent.br.id, item.tagId).then(function (response) {
                        $scope.tagsListApi.remove(item);
                    });

                },
                selected: function (item) {

                    // chiama servizio REST e se ok, azzera il componente
                    TagsAutoTaggingRestService.associateTagMovement(item.$parent.br.id, item.tagId).then(function (response) {

                    });

                }
            };

            $scope.source = {
                bookingRecords: [],
                paymentsDetails: []
            };
            $scope.filters = null;
            $scope.pagination = false;
            $scope.offsetMovements = 0;
            $scope.showPagination = true;

            /**
             * evento RESET_MOVEMENTS : reset puntatori
             */
            $scope.$on(Events.RESET_MOVEMENTS, function () {
                $scope.pagesize = $scope.limit;
            });

            /**
             *
             * @param br
             * @param showDetails
             * @returns {boolean}
             */
            // $scope.showDetails = function (br, showDetails) {
            //     /*
            //      if(showDetails || !$scope.source.paymentsDetails){
            //      return false;
            //      }
            //      */
            //     var res = $scope.source.paymentsDetails.payments.map(function (item) {
            //         return item.id === br.paymentId;
            //     });
            //
            //     return res.indexOf(true) !== -1;
            // };

            /**
             *
             * @param description
             * @returns {*}
             */
            $scope.sLineDetail = function (description) {
                var dArray = description.split("\n");
                return dArray[0];
            }

            /**
             *
             * @param momentDate
             * @returns {boolean}
             */
            $scope.showYear = function (momentDate) {
                return moment(momentDate).year() < moment().year() ? true : false;
            };


            /**
             * loadMore : interroga per altri movimenti
             */
            /**
             * loadMore : carica offset movimenti
             */
            $scope.loadMore = function () {

                // interroga la direttiva dei movimenti per sapere dei puntamenti
                var pointers = getNextPointers();

                // legge
                MovementsService.bookings($scope.filters, pointers).then(function (bookings) {

                    // assegna i record all'interno della direttiva
                    assignRecordsToBuffer(bookings);

                });

            }

            $scope.getPaymentPdfDownloadUrl = function (paymentId) {
                return MovementsService.getPaymentPdfDownloadUrl(paymentId);
            };

            $scope.getBookingDocumentDownloadUrl = function (bookingId) {
                return MovementsService.getBookingDocumentDownloadUrl(bookingId);
            };

            // adesso la direttiva è pronta !!!
            if ($scope && $scope.isReady && $scope.isReady.promise) {
                $scope.isReady.resolve();
            }


            $scope.checkShowDetail = function (br, showDetails) {
                return !showDetails;
            }

            /************************/
            /* FUNZIONI PRIVATE API */
            /************************/

            /**
             * assignRecordsToBuffer
             */
            function assignRecordsToBuffer(response) {

                // prima copia la nuova ondata di dati
                var bookingsRecords = angular.copy($scope.source.bookingRecords);
                var payments = angular.copy($scope.source.paymentsDetails.payments);

                if (response && response.bookingRecords && response.bookingRecords != null)
                    bookingsRecords = bookingsRecords.concat(response.bookingRecords);

                if (response && response.paymentsDetails && response.paymentsDetails.payments && response.paymentsDetails.payments != null)
                    payments = payments.concat(response.paymentsDetails.payments);

                // x BILLID
                bookingsRecords.forEach(function (br) {
                    br.tagVisible = $filter('PaymentUtilityFilterTag')({'section': 'visible'});
                    br.tagInsertable = $filter('PaymentUtilityFilterTag')({'section': 'insertable'});
                    br.billId = null;
                    payments.forEach(function (payment) {
                        if (payment.id === br.paymentId) {
                            br.billId = payment.billId;
                            if (br.billId !== null) {
                                br.description = $translate.instant('ebill.payment.type');
                                br.detail = $translate.instant('ebill.payment.type');
                            }
                        }

                    });
                });

                bookingsRecords.forEach(function (br) {
                    br._hasPayment = payments.find(function (payment) {
                            return payment.id === br.paymentId;
                        }) != undefined;
                });
                // riassegna per html

                $scope.source.bookingRecords = angular.copy(bookingsRecords);
                $scope.source.paymentsDetails.payments = angular.copy(payments);

                // pensa alla paginazione
                $scope.showPagination = true;
                if ($scope.options.pagination == false)
                    $scope.showPagination = false;

                if ($scope.options.pagination == true || $scope.options.pagination == undefined)
                    if (!response || parseInt(response.bookingRecords.length) < parseInt($scope.options.pageSize))
                        $scope.showPagination = false;
            }

            /**
             * startPointers
             * @returns {{offset: (number|*), limits: number}}
             */
            function startPointers() {

                $scope.offsetMovements = 0;
                $scope.source.bookingRecords = [];
                $scope.source.paymentsDetails.payments = [];

                return {offset: $scope.offsetMovements, limits: $scope.options.pageSize};
            }

            /**
             * getNextPointers
             * @returns {{offset: (number|*), limits: number}}
             */
            function getNextPointers() {
                $scope.offsetMovements = $scope.offsetMovements + $scope.options.pageSize;

                return {offset: $scope.offsetMovements, limits: $scope.options.pageSize};
            }

            /***************/
            /* METHODI API */
            /***************/

            /**
             * setOptions
             * @param options
             */
            function setOptions(options) {
                $scope.options = angular.extend({}, $scope.options, options);
            }

            /**
             * setData
             * @param data
             */
            /*
             function setData(data) {
             assignRecordsToBuffer(data);
             }
             */

            /**
             * getData : dati di default
             */
            function getDefaultData() {

                var deferred = $q.defer();

                // interroga la direttiva dei movimenti per sapere dei puntamenti
                var pointers = startPointers();

                // rimette i filtri di default passati la prima volta
                $scope.filters = $scope.options.filters;


                // legge
                MovementsService.defaultBookings(pointers.limits, pointers.offset).then(function (bookings) {

                    // assegna i record all'interno della direttiva
                    assignRecordsToBuffer(bookings);

                    // promessa risolta con successo
                    deferred.resolve({defaultBookings: bookings});

                });

                // modo 'promessa'
                return deferred.promise;

            }

            /**
             * getData
             */
            function getData(filters) {

                var deferred = $q.defer();

                // salva i filtri
                $scope.filters = filters;

                // interroga la direttiva dei movimenti per sapere dei puntamenti
                var pointers = startPointers();

                // legge
                MovementsService.bookings($scope.filters, pointers).then(function (bookings) {

                    // assegna i record all'interno della direttiva
                    assignRecordsToBuffer(bookings);

                    // via l'attesa
                    $scope.searching = false;

                    // promessa risolta con successo
                    deferred.resolve({bookings: bookings});
                });

                // modo 'promessa'
                return deferred.promise;

            }

            //  chiamata REST
            DebitCustomerService.getPromiseReady().then(
                function () {
                    $scope.debitCustomers = DebitCustomerService.getDebitCustomers();
                }
            );


        };

        return {
            templateUrl: 'common/directives/movements.html',
            restrict: 'E',
            controller: controller,
            scope: {
                dwnload: '=?',
                api: '=?',
                bvHideBalance: '=?',
                isReady: '='
            }
        };
    });
