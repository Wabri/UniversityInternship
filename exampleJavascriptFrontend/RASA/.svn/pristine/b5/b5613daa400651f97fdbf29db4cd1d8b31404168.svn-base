(function () {
    'use strict';

    angular.module('revux').directive('selectableList', selectableList);

    function selectableList($timeout) {

        var directive = {
            templateUrl: 'common/directives/selectableList/selectableList.directive.html',
            restrict: 'E',
            link: link,
            scope: {
                bvActivateInfiniteScroll: "=?",
                bvGroupShowedElements: "=?", //elementi mostrati all'avvio e numero di elementi aggiunti a seguito dello scroll
                api: "=",
                bvPromiseReady: "=",
                bvPreviewInclude: "=",
                bvDetailInclude: "=",
                bvButtonsInclude: "=",
                bvHeaderInclude: "=?",
                bvMethods: "=",
                showCheckBox: "=?",
                disableDetail: "=?",
                propertyId: "=?", //per non dover sempre specificare la property che identifica gli element nella invocazione dei metodi
                bvPagination: "=?", //'button' oppure 'scroll'
                showMoreElementsButtonText: "=?", // testo custom del pulsante showMoreEelement,
                messageNoRecords: "@",  // eventuale messaggio se non ci sono records
                scrollUpOnEventOptions:"=?"

            }
        };

        return directive;


        function link(scope,el) {

            scope.showMoreElements = showMoreElements;
            scope.checkSelectAll = checkSelectAll;
            scope.selectAll = selectAll;
            scope.deselectAll = deselectAll;
            scope.atLeastOneSelected = atLeastOneSelected;
            scope.clickOnPreview = clickOnPreview;
            scope.getNumberOfSelected = getNumberOfSelected;



            init();

            //////////////////////

            function init() {
                initApi();
                $timeout(function () {
                  scope.selectableListMinHeight= 'calc( 100vh - '+ (el.offset().top + 50) +'px )';
                }, 500);
            }

            function initApi() {
                scope.datasource=[];
                scope.api.setDatasource = setDatasource;
                scope.api.addDatasource = addDatasource;
                scope.api.getDatasource = getDatasource;
                scope.api.setValues = setValues;
                scope.api.getNumberOfSelected = getNumberOfSelected;
                scope.api.getPropertyOfSelected = getPropertyOfSelected;
                scope.api.setList = setList;  // mb
                scope.api.isReady = function () {
                    return true;
                };
                // adesso che si sono esposte i metodi API, la direttiva è pronta
                if (scope.bvPromiseReady)
                    scope.bvPromiseReady.resolve();
            }

            function setDatasource(data) {
                groupBy(data);
                scope.datasource = data;
                scope.$emit('start');
                checkSelectAll();
                scope.numShowedElements = scope.bvGroupShowedElements ? scope.bvGroupShowedElements : scope.datasource.length;
            }
            function getDatasource(){
              return scope.datasource;
            }
            function addDatasource(data) {
                scope.datasource=scope.datasource||[];
                scope.datasource = scope.datasource.concat(data);
                groupBy(scope.datasource);
                checkSelectAll();
                scope.numShowedElements = scope.datasource.length;
                return scope.datasource;
            }


            function setValues(data) {
                scope.values = data;
            }

            // mb
            function setList(data) {
                alert("sono in setlist : da implementare ???" + data);
            }

            function showMoreElements() {

                if(scope.api.showMoreElements && !scope.showMoreElementsDisabled && scope.datasource.length>0){
                  scope.showMoreElementsDisabled=true;
                  scope.api.showMoreElements().then(function(){
                    scope.showMoreElementsDisabled=false;
                  });
                }
                else{
                  scope.numShowedElements += scope.bvGroupShowedElements;
                }
            }

            function deselectAll() {
                if (scope.datasource) {
                    scope.datasource.forEach(function (element) {
                        element.selected = false;
                    });
                    scope.allSelected = false;
                    if (scope.api.onDeselectAll)
                        scope.api.onDeselectAll();
                }
            }

            function selectAll() {
                if (scope.datasource) {
                    scope.datasource.forEach(function (element) {
                        if (!element.noSelectable)
                            element.selected = true;
                    });
                    scope.allSelected = true;
                    scope.numShowedElements = scope.datasource.length
                    if (scope.api.onSelectAll)
                        scope.api.onSelectAll();
                }
            }

            function atLeastOneSelected() {
                return scope.datasource && scope.datasource.find(function (element) {
                        return element.selected;
                    });
            }

            function checkSelectAll() {
                //se trova tutti selezionati mette true altrimenti false
                if(scope.datasource.length==0)
                  return false;
                scope.allSelected = !scope.datasource.find(function (element) {
                    return !element.selected;
                });
            }

            function clickOnPreview(element) {

                if (scope.disableDetail) return false;

                if (scope.api.clickOnPreview) {
                    scope.api.clickOnPreview(element);
                }
                else {
                    element.showDetails = (element.showDetails) ? false : true;
                }

            }

            function getNumberOfSelected() {
                if (!scope.datasource)
                    return 0;
                var total = 0;
                scope.datasource.forEach(function (element) {
                    total += element.selected ? 1 : 0;
                });
                return total;
            }

            //di default ritorna gli id
            function getPropertyOfSelected(property) {
                property = property || scope.propertyId || 'id';
                if (!scope.datasource)
                    return [];
                return scope.datasource.filter(function (element) {
                    return element.selected;
                }).map(function (element) {
                    return element[property];
                });
            }

            //se ogni elemento ha groupbyString allora li raggruppa secondo tale valore, assume che siano già ordinati in tal senso
            function groupBy(data) {
                if (!data || data.length == 0 || data[0].groupByString == undefined) {
                    return;
                }
                var lastValue;
                data.forEach(function (element) {
                    element.topFilterString = element.groupByString != lastValue ? element.groupByString : undefined;
                    lastValue = element.topFilterString ? element.topFilterString : lastValue;
                });

            }

        }
    }


}());
