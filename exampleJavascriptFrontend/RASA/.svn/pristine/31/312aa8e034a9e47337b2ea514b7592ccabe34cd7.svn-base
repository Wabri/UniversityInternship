(function() {
  "use strict";

  angular.module(APP_NAME).directive("gpsCoords", gpsCoords);

  /**
   * bvWait : direttiva di attesa
   */
  function gpsCoords() {
    var directive = {
      restrict: "E",

      controller: controller,
      templateUrl: "common/directives/gpsCoords/gpsCoords.directive.html"
    };

    return directive;
  }


  /**
   *
   */
  function controller($scope, $rootScope, Geocoder, $q, $mdDialog, $timeout, EVENTS) {

    // var vm = this;
    $scope.input = {
      latitude: 0,
      longitude: 0
    };
    $scope.getLocation = getLocation;
    $scope.showPosition = showPosition;
    $scope.handleError = handleError;
    $scope.handleError2 = handleError2;

    $scope.Ctrl = Ctrl;



    function Ctrl() {

      $scope.message = "Waiting 2000ms for update";

      setTimeout(function() {
        $scope.$apply(function() {
          $scope.message = "Timeout called!";
        });
      }, 0);
    }



    function getLocation() {
      // debugger;
      if (navigator.geolocation) {
        if (navigator.geolocation.getCurrentPosition($scope.showPosition) == undefined) {
            console.log("ERRORE");
        }
        navigator.geolocation.getCurrentPosition($scope.showPosition, $scope.handleError, $scope.handleError2);
      } else {
        alert("Geolocation is not supported by this browser.");
      }
    }

    function showPosition(position) {
      // debugger;
      $scope.input.latitude = position.coords.latitude;
      $scope.input.longitude = position.coords.longitude;
      console.log(position.coords.latitude);
      console.log(position.coords.longitude);
      //////////////////////////////////////////
      /* HTML5 Geolocation */
      /* Current Coordinate */
      var lat = position.coords.latitude;
      var lng = position.coords.longitude;
      // debugger;
      var google_map_pos = new google.maps.LatLng(lat, lng);

      /* Use Geocoder to get address */
      var google_maps_geocoder = new google.maps.Geocoder();
      // debugger;
      google_maps_geocoder.geocode({
          'latLng': google_map_pos
        },
        function(results, status) {
          if (status == google.maps.GeocoderStatus.OK && results[0]) {
            console.log(results[0].formatted_address);
            $scope.input.addressComplete = results[0].formatted_address;
            $scope.Ctrl();
          }
        }
      );
      // function() { // fail cb
      // };

      /////////////////////////////////////////
      // $scope.input.addressComplete = position.????;
      $scope.Ctrl();
    }

    function handleError() {}

    function handleError2() {}





    $scope.geocode = geocode;

    function geocode() {
      var geocodingPromise = Geocoder.geocodeAddress($scope.input.address + " " + $scope.input.place);
      geocodingPromise.then(
        function(result) {
          $scope.geocodingResult =
            '(lat, lng) ' + result.lat + ', ' + result.lng +
            ' (address: \'' + result.formattedAddress + '\')';
          $scope.input.latitude = result.lat;
          $scope.input.longitude = result.lng;
          console.log(result.formattedAddress);
          $scope.input.addressComplete = result.formattedAddress;
          console.log($scope.input.address + $scope.input.place);
        },
        function(err) {
          $scope.geocodingResult = err.message;
          $scope.input.addressComplete = "NESSUN INDIRIZZO TROVATO";
        });

      $scope.geocodingTracker = new PromiseTracker(geocodingPromise);
    }


    $scope.PromiseTracker = PromiseTracker;

    function PromiseTracker(promise) {
      this.reset(promise);
    }

    PromiseTracker.prototype.isPending = function() {
      return this._tracked.length > 0;
    }

    PromiseTracker.prototype.reset = function(promise) {
      this._tracked = [];

      if (angular.isDefined(promise)) {
        this.track(promise);
      }
    }

    PromiseTracker.prototype.track = function(promise) {
      this._tracked.push(promise);

      promise.then(
        angular.bind(this, onDone),
        angular.bind(this, onDone));

      function onDone() {
        var index = this._tracked.indexOf(promise);
        this._tracked.splice(index, 1);
      }
    }
  }
  //     init();
  //
  //     /**
  //      *
  //      */
  //     function init() {
  //         initApi();
  //         initDefaults();
  //         initEvents();
  //     }
  //
  //     /**
  //      * initApi
  //      */
  //     function initApi() {
  //         // init api
  //         if ($scope.bvApi) $scope.bvApi.show = show;
  //
  //         // init primises
  //         if ($scope.bvPromiseReady) $scope.bvPromiseReady.resolve();
  //     }
  //
  //     function initDefaults() {
  //         if (!$scope.bvType) {
  //             $scope.bvType = "circular";
  //         }
  //     }
  //
  //     function initEvents() {
  //
  //         // intercetta gli eventi
  //         $rootScope.$on(EVENTS.BUSY_STARTED, function() {
  //             show();
  //         });
  //
  //         $rootScope.$on(EVENTS.BUSY_ENDED, function() {
  //             hide();
  //         });
  //     }
  //
  //     /***
  //      * show : mostra il dialogo di attesa
  //      */
  //     function show() {
  //         $mdDialog.show({
  //             contentElement: "#waitDialog",
  //             parent: angular.element(document.body),
  //             clickOutsideToClose: false
  //         });
  //     }
  //
  //     /**
  //      * hide : nasconde il dialogo di attesa
  //      */
  //
  //     function hide() {
  //         $mdDialog.hide();
  //     }
  // }
})();
